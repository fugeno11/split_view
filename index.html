<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Map Viewer — Slave</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.127/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#000; }
    #cesiumContainer { width:100%; height:100%; }

    /* ── Hide ALL Cesium Ion branding ── */
    .cesium-viewer-bottom,
    .cesium-credit-logoContainer,
    .cesium-credit-expand-link,
    .cesium-credit-lightbox-overlay,
    .cesium-credit-lightbox,
    .cesium-widget-credits,
    .cesium-credit-textContainer,
    .cesium-credit-text,
    [class*="cesium-credit"] {
      display: none !important;
    }

    /* Remove ALL Cesium toolbar — slave is passive */
    .cesium-viewer-toolbar { display: none !important; }

    /* Overlay label showing this is the slave */
    #slaveLabel {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      background: rgba(0,0,0,0.75);
      color: rgba(255,255,255,0.55);
      font-size: 11px;
      font-family: system-ui, sans-serif;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 12px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      pointer-events: none;
      user-select: none;
    }

    /* Tiny sync indicator — pulses when a camera message arrives */
    #syncDot {
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #6ee86e;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.05s ease-in;
    }
    #syncDot.pulse {
      opacity: 1;
      transition: none;
    }
  </style>
</head>
<body>

<div id="cesiumContainer"></div>
<div id="slaveLabel">Slave View — Camera Synced</div>
<div id="syncDot"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.127.0/Cesium.js"></script>
<script>
/* ═══════════════════════════════════════════════════════════════════
   CONFIG — must match master
═══════════════════════════════════════════════════════════════════ */
const PROJECT_LOCATION = { lon: 80.496093, lat: 16.542750, height: 350 };
const ORTHO_TMS_URL    = "https://amaravati-3d-data.s3.ap-southeast-2.amazonaws.com/3D_Jan2026/2D-Ortho-Geotiff/2D_ortho_AGC_Building_Zone_27012026/";
const MASTER_ORIGIN    = window.location.origin; // same domain

Cesium.Ion.defaultAccessToken = undefined;

const creditDiv = document.createElement("div");
creditDiv.style.display = "none";
document.body.appendChild(creditDiv);

/* ═══════════════════════════════════════════════════════════════════
   VIEWER — minimal, passive, no controls needed
═══════════════════════════════════════════════════════════════════ */
const viewer = new Cesium.Viewer("cesiumContainer", {
  terrain:              undefined,
  timeline:             false,
  animation:            false,
  geocoder:             false,
  homeButton:           false,
  sceneModePicker:      false,   // slave matches master's scene mode
  baseLayerPicker:      false,
  navigationHelpButton: false,
  infoBox:              false,
  selectionIndicator:   false,
  creditContainer:      creditDiv
});

/* ── Kill credits ── */
function killCredits() {
  document.querySelectorAll(
    ".cesium-viewer-bottom,.cesium-credit-logoContainer,.cesium-credit-expand-link," +
    ".cesium-widget-credits,.cesium-credit-textContainer,.cesium-credit-text"
  ).forEach(el => { el.style.cssText = "display:none!important"; });
}
[0,300,700,1500,3000].forEach(t => setTimeout(killCredits, t));

/* ── Basemap ── */
viewer.imageryLayers.removeAll();
viewer.imageryLayers.addImageryProvider(
  new Cesium.OpenStreetMapImageryProvider({ url: "https://a.tile.openstreetmap.org/" })
);
(async () => {
  try {
    const p = await Cesium.TileMapServiceImageryProvider.fromUrl(ORTHO_TMS_URL, {
      fileExtension: "png", maximumLevel: 22, flipXY: false
    });
    viewer.imageryLayers.addImageryProvider(p);
  } catch { /* fall back to OSM */ }
})();

/* ── Initial camera matching master's default ── */
viewer.camera.setView({
  destination: Cesium.Cartesian3.fromDegrees(PROJECT_LOCATION.lon, PROJECT_LOCATION.lat, PROJECT_LOCATION.height),
  orientation: { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-35), roll: 0 }
});
viewer.scene.globe.depthTestAgainstTerrain = false;

/* ═══════════════════════════════════════════════════════════════════
   CAMERA SYNC — SLAVE  (Page 2)

   Receives CESIUM_CAMERA_SYNC messages from the master window
   and applies them WITHOUT triggering its own camera events back.

   Loop prevention:
   - We never postMessage anything back to the master from here.
   - The _isSyncing guard in the master prevents its own listeners
     from re-broadcasting an update it already sent.
   
   Smooth application:
   - We use viewer.camera.setView() (instant, no animation jank)
     for high-frequency changed events.
   - We do NOT use flyTo() here — it causes lag + shaking on rapid
     incoming messages.
   
   Performance:
   - requestAnimationFrame batching: if messages arrive faster than
     one frame, we only apply the last one per frame.
═══════════════════════════════════════════════════════════════════ */

let _pendingCamera   = null;  // latest unprocessed camera payload
let _rafScheduled    = false; // true if rAF is queued

const syncDot = document.getElementById("syncDot");
let _dotTimer = null;

function pulseDot() {
  syncDot.classList.add("pulse");
  clearTimeout(_dotTimer);
  _dotTimer = setTimeout(() => syncDot.classList.remove("pulse"), 120);
}

/**
 * Apply a camera payload immediately via setView.
 * setView is synchronous, instant, and does NOT fire camera events,
 * so it cannot create a feedback loop.
 */
function applyCamera(cam) {
  try {
    viewer.camera.setView({
      destination: Cesium.Cartesian3.fromDegrees(cam.lon, cam.lat, cam.alt),
      orientation: {
        heading: cam.heading,
        pitch:   cam.pitch,
        roll:    cam.roll
      }
    });
    viewer.scene.requestRender();
    pulseDot();
  } catch (err) {
    console.warn("[Slave] applyCamera error:", err);
  }
}

/**
 * rAF-batched apply: absorbs bursts of messages, applies only the
 * latest camera state per animation frame (~16ms at 60fps).
 * This is key to avoiding stuttering when master fires many events.
 */
function scheduleApply() {
  if (_rafScheduled) return;
  _rafScheduled = true;
  requestAnimationFrame(() => {
    _rafScheduled = false;
    if (_pendingCamera) {
      applyCamera(_pendingCamera);
      _pendingCamera = null;
    }
  });
}

/**
 * postMessage listener.
 * Security: always check origin and message type.
 */
window.addEventListener("message", (event) => {
  // ── Security: reject cross-origin messages ──
  if (event.origin !== MASTER_ORIGIN) return;

  const msg = event.data;
  if (!msg || msg.type !== "CESIUM_CAMERA_SYNC") return;

  const cam = msg.camera;
  if (
    typeof cam.lon !== "number" || typeof cam.lat !== "number" ||
    typeof cam.alt !== "number" || typeof cam.heading !== "number" ||
    typeof cam.pitch !== "number" || typeof cam.roll !== "number"
  ) {
    console.warn("[Slave] Received malformed camera payload:", cam);
    return;
  }

  // Queue the update; scheduleApply batches rapid-fire messages
  _pendingCamera = cam;
  scheduleApply();
});

/* ═══════════════════════════════════════════════════════════════════
   OPTIONAL: Disable user input on slave so it stays purely passive.
   Comment out if you want users to be able to interact with slave too.
═══════════════════════════════════════════════════════════════════ */
viewer.scene.screenSpaceCameraController.enableRotate    = false;
viewer.scene.screenSpaceCameraController.enableTranslate = false;
viewer.scene.screenSpaceCameraController.enableZoom      = false;
viewer.scene.screenSpaceCameraController.enableTilt      = false;
viewer.scene.screenSpaceCameraController.enableLook      = false;
</script>
</body>
</html>
