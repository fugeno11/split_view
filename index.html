<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Map Viewer — Slave</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.127/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#000; }
    #cesiumContainer { width:100%; height:100%; }

    .cesium-viewer-bottom,.cesium-credit-logoContainer,.cesium-credit-expand-link,
    .cesium-credit-lightbox-overlay,.cesium-credit-lightbox,.cesium-widget-credits,
    .cesium-credit-textContainer,.cesium-credit-text,[class*="cesium-credit"]
    { display:none !important; }

    /* No toolbar needed on slave */
    .cesium-viewer-toolbar { display:none !important; }

    /* Joystick activity pulse dot */
    #joyDot {
      position:fixed; bottom:10px; right:10px; z-index:100;
      width:8px; height:8px; border-radius:50%;
      background:#222;
      transition:background .1s, box-shadow .1s;
      pointer-events:none;
    }
    #joyDot.pulse { background:#00e5ff; box-shadow:0 0 8px #00e5ff; }
  </style>
</head>
<body>
<div id="cesiumContainer"></div>
<div id="joyDot"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.127.0/Cesium.js"></script>
<script>
/* ══════════════════════════════════════════════════════════
   SLAVE PAGE — receives JOYSTICK_MOVE from master iframe

   Key design choices:
   - scene.preRender holds the LATEST joy values → 60fps smooth
     regardless of how fast messages arrive (rAF-batched implicitly)
   - cam.moveRight / cam.moveForward = synchronous, no events fired
   - We NEVER postMessage back → zero loop risk
   - User interaction disabled (purely joystick-driven)
══════════════════════════════════════════════════════════ */

const PROJECT_LOC   = { lon: 80.496093, lat: 16.542750, height: 350 };
const ORTHO_TMS_URL = "https://amaravati-3d-data.s3.ap-southeast-2.amazonaws.com/3D_Jan2026/2D-Ortho-Geotiff/2D_ortho_AGC_Building_Zone_27012026/";

Cesium.Ion.defaultAccessToken = undefined;
const creditDiv = document.createElement("div");
creditDiv.style.display = "none";
document.body.appendChild(creditDiv);

const viewer = new Cesium.Viewer("cesiumContainer", {
  terrain:undefined, timeline:false, animation:false,
  geocoder:false, homeButton:false, sceneModePicker:false,
  baseLayerPicker:false, navigationHelpButton:false,
  infoBox:false, selectionIndicator:false,
  creditContainer:creditDiv
});

function killCredits() {
  document.querySelectorAll(
    ".cesium-viewer-bottom,.cesium-credit-logoContainer,.cesium-credit-expand-link," +
    ".cesium-widget-credits,.cesium-credit-textContainer,.cesium-credit-text"
  ).forEach(el => { el.style.cssText = "display:none!important"; });
}
[0,300,700,1500,3000].forEach(t => setTimeout(killCredits, t));

viewer.imageryLayers.removeAll();
viewer.imageryLayers.addImageryProvider(
  new Cesium.OpenStreetMapImageryProvider({ url:"https://a.tile.openstreetmap.org/" })
);
(async () => {
  try {
    const p = await Cesium.TileMapServiceImageryProvider.fromUrl(ORTHO_TMS_URL, {
      fileExtension:"png", maximumLevel:22, flipXY:false
    });
    viewer.imageryLayers.addImageryProvider(p);
  } catch {}
})();

viewer.camera.setView({
  destination: Cesium.Cartesian3.fromDegrees(PROJECT_LOC.lon, PROJECT_LOC.lat, PROJECT_LOC.height),
  orientation: { heading:0, pitch:Cesium.Math.toRadians(-35), roll:0 }
});
viewer.scene.globe.depthTestAgainstTerrain = false;

/* ── Disable user camera input ─ slave follows master only ── */
viewer.scene.screenSpaceCameraController.enableRotate    = false;
viewer.scene.screenSpaceCameraController.enableTranslate = false;
viewer.scene.screenSpaceCameraController.enableZoom      = false;
viewer.scene.screenSpaceCameraController.enableTilt      = false;
viewer.scene.screenSpaceCameraController.enableLook      = false;

/* ── Joystick state (written by message handler, read by preRender) ── */
let joy = { x:0, y:0, speed:1 };

const dot = document.getElementById("joyDot");
let dotTimer = null;
function pulseDot() {
  dot.classList.add("pulse");
  clearTimeout(dotTimer);
  dotTimer = setTimeout(() => dot.classList.remove("pulse"), 150);
}

/* ── Receive joystick messages from master ── */
window.addEventListener("message", e => {
  const d = e.data;
  if (!d || d.type !== "JOYSTICK_MOVE") return;
  // Validate
  if (typeof d.x !== "number" || typeof d.y !== "number") return;
  joy.x = d.x;
  joy.y = d.y;
  joy.speed = typeof d.speed === "number" ? d.speed : 1;
  pulseDot();
});

/* ══════════════════════════════════════════════════════════
   SCENE PRE-RENDER — apply joystick to slave camera
   
   We read joy.x / joy.y and apply the SAME speed value
   that the master calculated (passed in the message), so
   both cameras move the exact same distance per frame.
══════════════════════════════════════════════════════════ */
const DEAD_ZONE = 0.04;

viewer.scene.preRender.addEventListener(() => {
  const { x, y, speed } = joy;
  if (Math.abs(x) < DEAD_ZONE && Math.abs(y) < DEAD_ZONE) return;

  const cam = viewer.camera;
  if (Math.abs(x) > DEAD_ZONE) cam.moveRight(x * speed);
  if (Math.abs(y) > DEAD_ZONE) cam.moveForward(y * speed);
});
</script>
</body>
</html>
